===========kernel configuration============\
1. log level defined in <include/kernel.h>
	KERN_EMERG    /* system is unusable                   */
	KERN_ALERT    /* action must be taken immediately     */
	KERN_CRIT     /* critical conditions                  */
	KERN_ERR      /* error conditions                     */
	KERN_WARNING  /* warning conditions                   */
	KERN_NOTICE   /* normal but significant condition     */
	KERN_INFO     /* informational                        */
	KERN_DEBUG    /* debug-level messages                 */
	
	1.1 eg:  printk(KERN_DEBUG "%d", HZ);
	1.2 为了防止log太多撑爆ring buffer，启动时使用参数log_buf_len=104857600来指定buffer大小，这里为100M。
	boot param without quite & splash。

2. configuration befor debug kernel with gdb and qemu
        #Make sure you have no stale .o files and dependencies lying around:
	make mrproper
	make x86_64_defconfig

	cat <<EOF >.config-fragment
	CONFIG_DEBUG_INFO=y
	CONFIG_GDB_SCRIPTS=y
	CONFIG_X86_NEED_RELOCS=n
	CONFIG_RANDOMIZE_MEMORY=n
	CONFIG_UNWINDER_ORC=n
	EOF

	./scripts/kconfig/merge_config.sh .config .config-fragment
3. gdb : optimized out proplem when print variable.
	make menuconfig
	search key word "optimize"  setting GCC optimization to n to avoiding those problem.
	 Location:                                                                                                                                                           │  
	   │     -> General setup                                                                                                                                                  │  
	     │ (1)   -> Compiler optimization level
	ref: https://lkml.org/lkml/2010/11/28/211
	如果删除不干净，直接编辑Makefile，删除-O* 的compiler FLAG. 编译出错，
	删除.config 中的compiler optimize option后，执行make命令，要求必须compiler optimization 二选一，： optimize for size; optimize for performance.
	test failed. You MUST compile  kerenel code with optimize option:  https://lists.kernelnewbies.org/pipermail/kernelnewbies/2016-August/016689.html
4.
	make -j $(nproc)
============terminal 1=====================
qemu-system-x86_64 -m 2048 -kernel arch/x86/boot/bzImage -gdb tcp::6633 -nographic -serial mon:stdio -append 'console=ttyS0' -S --enable-kvm

REF:
bzimage --> https://unix.stackexchange.com/questions/5518/what-is-the-difference-between-the-following-kernel-makefile-terms-vmlinux-vml/5602#5602

============terminal 2=====================
#gdb
(gdb) add-auto-load-safe-path /home/milo/test/linux-4.19.34/
(gdb) file /home/milo/test/linux-4.19.34/vmlinux
Reading symbols from /home/milo/test/linux-4.19.34/vmlinux...done.
(gdb) directory /home/milo/test/linux-4.19.34/
Source directories searched: /home/milo/test/linux-4.19.34:$cdir:$cwd
(gdb) target remote:6633
Remote debugging using :6633
0x000000000000fff0 in cpu_hw_events ()
(gdb) 
=================configuration=============
也可以把以上命令保存到当前目录(/home/binss/work/GDB-Kernel/)的.gdbinit中，然后在~/.gdbinit中添加：

add-auto-load-safe-path /home/binss/work/GDB-Kernel/.gdbinit

或者直接添加在~/.gdbinit

==================挂载磁盘==================

前面的指令拉起的VM会挂在initramfs，因为没有指定要挂载的磁盘，可以通过hda挂载已有磁盘并配置root参数，从而成功进入某个虚拟机：

sudo qemu-system-x86_64 -m 2048 -kernel /home/binss/work/KVM-Learning/arch/x86/boot/bzImage -initrd ~/work/initrd.img-4.4.0-66-generic -hda myvm2.img -gdb tcp::8889 -nographic -serial mon:stdio -append 'root=/dev/sda1 console=ttyS0' --enable-kvm
当然为了加强鲁棒性，建议使用UUID来指定root设备，UUID可以在进入系统后查询/boot/grub/grub.cfg得到。

sudo qemu-system-x86_64 -m 2048 -kernel /home/binss/work/KVM-Learning/arch/x86/boot/bzImage -initrd ~/work/initrd.img-4.4.0-66-generic -hda myvm2.img 
=====================打断点=================
然后我们就能够通过函数名进行断点了，比如断在入口：
hbreak start_kernel
hbreak security_init
断点的位置在
：https://github.com/torvalds/linux/blob/v4.2/init/main.c#L497
ref:https://stackoverflow.com/questions/18266063/does-kernel-have-main-function/33422401#33422401
____
REF:
https://stackoverflow.com/questions/11408041/how-to-debug-the-linux-kernel-with-gdb-and-qemu
https://github.com/cirosantilli/linux-kernel-module-cheat/tree/c7bbc6029af7f4fab0a23a380d1607df0b2a3701
https://github.com/cirosantilli/linux-kernel-module-cheat#myinsmod
https://wiki.ubuntu.com/Kernel/KernelDebuggingTricks
https://www.elinux.org/Debugging_The_Linux_Kernel_Using_Gdb
https://www.phoronix.com/scan.php?page=news_item&px=Linux-4.8-ASLR-Kernel-Mem-Sects

system.map vs /proc/kallsysms
/proc/kallsysms have symbols of dynamically loaded modules as well static code and system.map is symbol tables of only static code.
You can not be really sure if system.map will be available on your system. When kernel and system.map mismatch you keep seeing System.map does not match actual kernel warning. So in that case/proc/kallsyms is the symbols of running kernel.
System.map isn't just useful for debugging kernel oopses. A few drivers need System.map to resolve symbols since they're linked against kernel headers instead of glibc). They won't work correctly without the System.map for the particular kernel currently running.
/proc/kallsysms have symbols of dynamically loaded modules as well static code and system.map is symbol tables of only static code.
https://stackoverflow.com/questions/28936630/system-map-file-and-proc-kallsyms
https://stackoverflow.com/questions/28936630/system-map-file-and-proc-kallsyms
